# 双杆导轨电磁阻尼系统的解析递推与事件驱动仿真统一报告

（面向学术/工程读者；中文简体；撰写日期：2026-02-10）

本报告以你上传的 **forGPT.md** 为主线（“双杆理想模型→无截断离散递推→事件化碰撞映射→矩阵化统一框架→外力/有界磁场扩展”），补齐严格推导、证明、统一状态机表述，并给出可复现的 **MATLAB timer 事件驱动仿真**框架与示例代码。报告中将明确标注：**[复现]**（直接复现 forGPT.md 的结论/公式结构）、**[补充推导]**（为严谨性补写的推导/证明）、**[默认/未指定]**（原文未明确而本报告需作出选择的部分）。

为便于你追溯原始材料，本报告在“参考文献与交付物”中给出 forGPT.md 的本地链接（你明确要求“引用并链接”）。

## 需求映射表

| 需求编号 | 覆盖位置（本报告小节） | 备注 |
|---|---|---|
| 一、总体目标与读者定位 | 引言与统一目标 | 明确整合目标、读者假设 |
| 二、模型重述与符号说明 | 模型与符号体系 | 含符号表（含单位/未指定） |
| 三、连续解析解推导 | 连续时间解析解与严格性质 | 含存在唯一性与质心守恒证明 |
| 四、离散无截断误差递推 | 无截断误差离散递推与矩阵表达 | 含矩阵指数/齐次坐标等价性 |
| 五、事件化碰撞 | 事件化碰撞与有界磁场状态机 | 含判据、映射、伪代码、ρ讨论 |
| 六、能量/热量递推与二次项问题 | 能量与热量递推及二次项扩维 | 含两种扩维策略与比较 |
| 七、矩阵化统一框架 | 无截断误差离散递推与矩阵表达 + 事件化碰撞与有界磁场状态机 | 含符号一致性问题修正 |
| 八、MATLAB 仿真指导 | MATLAB timer 事件驱动仿真与验证 | 含可运行示例与根定位 |
| 九、数值验证与测试用例 | MATLAB timer 事件驱动仿真与验证 | ≥4用例、预期结果、容差 |
| 十、复杂度与稳定性 | MATLAB timer 事件驱动仿真与验证 | 复杂度与漏检风险缓解 |
| 十一、扩展与应用建议 | 扩展、未指定项与参考文献及快速开始 | 链式系统/控制/扰动等 |
| 十二、参考文献与优先来源 | 扩展、未指定项与参考文献及快速开始 | 含官方文档/教材/论文 |
| 十三、报告格式与交付物 | 全文 + 快速开始 | 快速开始≤100行 |
| 十四、未指定项与假设声明 | 模型与符号体系 + 扩展、未指定项与参考文献及快速开始 | 专门列出 |
| 十五、输出风格与细节要求 | 全文 | 方程编号、表格、图建议 |

image_group{"layout":"carousel","aspect_ratio":"16:9","query":["sliding rod on rails magnetic field motional emf schematic","two masses on a frictionless track collision diagram","eddy current braking schematic"],"num_per_query":1}

## 引言与统一目标

本节要点：本报告把 forGPT.md 的“解析递推”思想组织为**线性（或分段线性）系统的解析流映射**，并把“碰撞/进出有界磁场边界”统一成**事件集合**，从而形成可直接落地的 timer 事件驱动仿真框架。其核心方法论是：**推进=解析推进（无截断）+事件定位+事件映射**的循环。

**总体目标（对应需求一）**：  
1) **[复现]** 双杆在无界匀强磁场中的理想模型：相对模态指数衰减、质心模态守恒/匀加速；  
2) **[复现]** “一步递推（无截断误差）”离散公式：用解析解直接构造离散映射；  
3) **[复现]** 碰撞的事件化分段解析：碰撞瞬时映射（恢复系数 ρ）+段间解析推进；  
4) **[复现+补充推导]** deepseek 段落中的矩阵化框架：用矩阵指数/齐次坐标把仿射映射统一为线性映射，并讨论二次热量量的扩维闭合；同时指出并修正其符号一致性风险点。

**读者定位（对应需求一）**：假定读者具备控制/动力学/应用数学本科以上基础，熟悉 ODE、线性代数、数值仿真与 MATLAB；对电磁学只要求接受 **法拉第电磁感应定律**与**楞次定律**的基本形式（见式 (1)–(2)）。citeturn5search0turn5search1

## 模型与符号体系

本节要点：首先固定符号与约定（避免 deepseek 文本里“符号一处不一致导致整体符号翻转”的风险）；其次明确“未指定项”；最后给出统一状态变量选择的两条路线：原坐标 \((x_A,v_A,x_B,v_B)\) 与模态坐标 \((x_{cm},v_{cm},x,u)\)。

### 模型假设与基本约定（对应需求二）

**[复现] 空间与运动学**（1D 沿导轨方向）  
- 两导体棒（质点化）A、B 沿导轨方向运动，位置 \(x_A(t),x_B(t)\)，速度 \(v_A=\dot x_A,\,v_B=\dot x_B\)。  
- 定义相对量  
\[
x(t)\equiv x_B-x_A,\qquad u(t)\equiv \dot x=v_B-v_A.
\tag{1}
\]
- 约定“无穿透”约束：\(x(t)\ge 0\)。当 \(x\to 0\) 触发碰撞事件（见后文）。

**[复现] 电磁与回路**（无界匀强磁场为基准，再推广到有界磁场）  
- 导轨间距（棒长）为 \(L\)，磁感应强度为 \(B\)（垂直导轨平面），回路总电阻为 \(R\)。  
- 定义电磁系数  
\[
k\equiv \frac{B^2L^2}{R}\ge 0.
\tag{2}
\]
- **[复现+补充推导]** 利用磁通 \(\Phi=BL\cdot (\text{有效重叠长度})\)，由法拉第定律得感应电动势  
\[
\varepsilon=-\frac{d\Phi}{dt}.
\tag{3}
\]
这是推导“阻尼力 \(\propto\) 速度/相对速度”的起点。citeturn5search0

**[复现] 外力与碰撞参数**  
- 外力 \(F_A,F_B\) 沿导轨方向（可为常值或“分段常值”）。  
- 碰撞采用一维恢复系数模型 \(\rho\in[0,1]\)：相对速度满足  
\[
u^+ = -\rho u^-.
\tag{4}
\]
该形式是“相对速度反向并按 \(\rho\) 缩放”的标准定义。citeturn6search2turn0search43

### 符号表（对应需求二）

> 单位若原文未指定，则标注“未指定”，并给出常用 SI 建议；你可在实现时统一用 SI。

| 符号 | 含义 | 建议单位 | 首次出现 |
|---|---|---|---|
| \(x_A,x_B\) | 杆 A/B 的位置 | m（未指定；建议 SI） | 式 (1) |
| \(v_A,v_B\) | 杆 A/B 的速度 | m·s⁻¹（未指定） | 式 (1) |
| \(x\) | 相对位置 \(x_B-x_A\) | m（未指定） | 式 (1) |
| \(u\) | 相对速度 \(v_B-v_A\) | m·s⁻¹（未指定） | 式 (1) |
| \(m_A,m_B\) | 两杆质量 | kg（未指定） | 式 (9) |
| \(M\) | 总质量 \(m_A+m_B\) | kg（未指定） | 式 (10) |
| \(\mu\) | 约化质量 \(\frac{m_Am_B}{m_A+m_B}\) | kg（未指定） | 式 (11) |
| \(B\) | 磁感应强度 | T（未指定） | 式 (2)(3) |
| \(L\) | 导轨间距/杆长 | m（未指定） | 式 (2)(3) |
| \(R\) | 回路总电阻 | Ω（未指定） | 式 (2) |
| \(k\) | 电磁阻尼系数 \(B^2L^2/R\) | N·s·m⁻¹（等价量纲；未指定） | 式 (2) |
| \(\alpha\) | 相对模态衰减率 | s⁻¹（未指定） | 式 (15) |
| \(\rho\) | 恢复系数 | 无量纲 | 式 (4) |
| \(\Delta t\) | 离散步长（仿真时间步） | s | 式 (22) |
| \(x_L,x_R\) | 有界磁场区间边界 | m（未指定） | 式 (40) |
| \(\ell\) | 回路与磁场区间的有效重叠长度 | m（未指定） | 式 (40) |
| \(Q\) | 累计焦耳热（电阻热） | J（未指定） | 式 (55) |
| \(Q_{coll}\) | 碰撞内耗热（形变/声等） | J（未指定） | 式 (61) |

### 未指定项与默认选择（对应需求十四）

**[默认/未指定]** forGPT.md 主要给出结构性公式，以下细节需你在工程实现中明确：  
1) **单位系统**：未指定；本报告建议 SI。  
2) **接触几何**：默认“点接触、瞬时冲击、无粘连摩擦”；若需有限接触时间/弹簧-阻尼接触，属于模型扩展（见“扩展建议”）。  
3) **电路模型**：默认回路总电阻 \(R\) 常值、忽略电感/电容；若加入电感 \(L_e\)，电流不再瞬时跟随，电磁力将引入额外状态并改变“无截断一步递推”的简洁性（扩展章节给出方向）。  
4) **磁场方向与回路正方向**：原文以“结果能量耗散为正”固定了符号；本报告在推导中以“楞次定律→阻尼总是反对 \(\dot\Phi\)”为一致性原则。citeturn5search1turn4search47

## 连续时间解析解与严格性质

本节要点：从电磁感应到动力学方程，严格推出相对模态 ODE；证明“无外力时质心速度守恒”；给出 \(x_A(t),x_B(t)\) 的闭式；并用存在唯一性定理保证模型在每个分段内解的良定性。

### 从电磁链路到动力学方程（对应需求三）

**[复现+补充推导]** 无界匀强磁场且两杆均处于磁场中时，回路面积 \(S=Lx\)，磁通  
\[
\Phi = BLx.
\tag{5}
\]
由法拉第定律（式 (3)）得  
\[
\varepsilon=-\frac{d\Phi}{dt}=-BL\dot x=-BLu,
\qquad
I=\frac{\varepsilon}{R}= -\frac{BL}{R}u.
\tag{6}
\]
磁场对载流导体的力可写为 \(\mathbf F=I\,\boldsymbol{\ell}\times\mathbf B\)，量级 \(F=BIL\)（方向由右手定则确定）。citeturn4search1turn4search48

将式 (6) 代入并定义 \(k=B^2L^2/R\)（式 (2)），得到两杆受到等大反向的电磁耦合力。选择与 forGPT.md 一致的符号约定，可写成
\[
m_A\dot v_A = F_A + k\,u,\qquad
m_B\dot v_B = F_B - k\,u.
\tag{7}
\]
其中 \(F_A,F_B\) 为外力（无外力则取 0）。

### 质心模态与相对模态分解（对应需求三）

定义总质量与约化质量
\[
M\equiv m_A+m_B,\qquad
\mu\equiv \frac{m_Am_B}{m_A+m_B}.
\tag{8}
\]
定义质心速度
\[
v_{cm}\equiv \frac{m_Av_A+m_Bv_B}{M}.
\tag{9}
\]

**命题 1（质心动量方程）**：由式 (7) 得
\[
\frac{d}{dt}(m_Av_A+m_Bv_B)=F_A+F_B
\quad\Rightarrow\quad
\dot v_{cm}=\frac{F_A+F_B}{M}\equiv a_{cm}.
\tag{10}
\]

**证明**（严格）：对式 (7) 两式相加，
\[
m_A\dot v_A+m_B\dot v_B=(F_A+F_B)+(k u-ku)=F_A+F_B,
\]
再除以 \(M\) 即得式 (10)。证毕。

> 推论：**无外力** \(F_A=F_B=0\) 时，\(\dot v_{cm}=0\)，质心速度守恒（forGPT.md 的“亮点 1”）。这是内部电磁耦合力“成对抵消”的直接结果。

再定义相对速度 \(u=v_B-v_A\)。由式 (7) 作差：
\[
\dot u=\dot v_B-\dot v_A
=\frac{F_B}{m_B}-\frac{F_A}{m_A}-k\Big(\frac1{m_A}+\frac1{m_B}\Big)u.
\tag{11}
\]
定义
\[
\alpha \equiv k\Big(\frac1{m_A}+\frac1{m_B}\Big)=\frac{k}{\mu},\qquad
b\equiv \frac{F_B}{m_B}-\frac{F_A}{m_A},
\tag{12}
\]
则相对模态满足一阶线性 ODE：
\[
\dot u = b-\alpha u.
\tag{13}
\]

### 相对量解析解、位置解析式与存在唯一性（对应需求三）

**[复现]** 当 \(F_A,F_B\) 在一个分段内取常量（或“分段常量”）时，式 (13) 解为
\[
u(t)=u_\infty + (u_0-u_\infty)e^{-\alpha t},
\qquad
u_\infty\equiv \frac{b}{\alpha}.
\tag{14}
\]
特别地，无外力 \(b=0\) 时
\[
u(t)=u_0 e^{-\alpha t},
\tag{15}
\]
即 forGPT.md 的“亮点 2”。

对 \(\dot x=u\) 积分（同一分段内），得
\[
x(t)=x_0+u_\infty t+\frac{u_0-u_\infty}{\alpha}\big(1-e^{-\alpha t}\big).
\tag{16}
\]

质心位置由 \(\dot x_{cm}=v_{cm}\) 且 \(v_{cm}(t)=v_{cm,0}+a_{cm}t\) 得
\[
x_{cm}(t)=x_{cm,0}+v_{cm,0}t+\frac12 a_{cm}t^2.
\tag{17}
\]

由 \((v_{cm},u)\) 可反解两杆速度（forGPT.md 的关键代数关系）：
\[
v_A=v_{cm}-\frac{m_B}{M}u,\qquad
v_B=v_{cm}+\frac{m_A}{M}u.
\tag{18}
\]
同理由 \((x_{cm},x)\) 反解位置：
\[
x_A=x_{cm}-\frac{m_B}{M}x,\qquad
x_B=x_{cm}+\frac{m_A}{M}x.
\tag{19}
\]
式 (14)–(19) 共同给出 \((x_A(t),v_A(t),x_B(t),v_B(t))\) 的分段闭式解。

**存在性与唯一 controversial**：每个分段内系统是常系数线性 ODE（或常输入线性 ODE），右端对状态是全局 Lipschitz，因此初值问题存在唯一解。可以用 Picard–Lindelöf 定理给出严格保证。citeturn7search46  
事件点（碰撞/边界切换）处我们采用“先精确定位事件时刻，再施加映射”的规则，使得分段拼接仍是确定性的（见后文状态机算法）。

## 无截断误差离散递推与矩阵表达

本节要点：把连续解析解直接作为离散时间映射，解释“无截断误差”的含义；给出从 \(u_n\) 恢复 \(v_A^n,v_B^n,x_A^n,x_B^n\) 的闭式公式；并用矩阵指数/齐次坐标证明与线性系统离散化等价。

### “无截断误差”离散映射的来源（对应需求四）

**定义（本报告采用）**：若离散更新 \(s_{n+1}=F_{\Delta t}(s_n)\) 满足  
\[
F_{\Delta t}(s_n)=\varphi(\Delta t; s_n),
\tag{20}
\]
其中 \(\varphi(t;s_0)\) 是连续系统从初值 \(s_0\) 演化到时间 \(t\) 的**精确流映射**，则称该离散法对该系统为“无截断误差”（误差仅来自浮点与事件根求解误差）。这与“用泰勒截断逼近微分方程”的常见显式/隐式方法不同。

对相对模态式 (13)，在一段时间 \(\tau\) 内闭式推进为
\[
u^{+}=u_\infty+(u-u_\infty)e^{-\alpha \tau},
\qquad
x^{+}=x+u_\infty \tau+\frac{u-u_\infty}{\alpha}\big(1-e^{-\alpha \tau}\big).
\tag{21}
\]
取 \(\tau=\Delta t\) 且记 \(\lambda=e^{-\alpha\Delta t}\)，得到一步递推：
\[
u_{n+1}=u_\infty+(u_n-u_\infty)\lambda.
\tag{22}
\]
无外力 \(u_\infty=0\) 时即
\[
u_{n+1}=u_n e^{-\alpha\Delta t}.
\tag{23}
\]
这正是 forGPT.md 的“解析一步递推（核心）”。

### 从相对量恢复到原变量的闭式更新（对应需求四）

在无外力（\(v_{cm}\) 常量）时，先由初值计算
\[
v_{cm}=\frac{m_Av_{A0}+m_Bv_{B0}}{M}.
\tag{24}
\]
然后对每一步（已知 \(u_n\to u_{n+1}\)）使用式 (18) 得
\[
v_{A,n}=v_{cm}-\frac{m_B}{M}u_n,\qquad
v_{B,n}=v_{cm}+\frac{m_A}{M}u_n,
\tag{25}
\]
以及同样形式的 \(n+1\) 时刻速度。

位置更新可用“端点差”避免写 \(1-\lambda\)：
\[
\Delta x_n=\int_{t_n}^{t_{n+1}}u(t)\,dt
=\frac{u_n-u_{n+1}}{\alpha}.
\tag{26}
\]
再由式 (19) 或直接积分 \(v_A,v_B\) 得
\[
x_{A,n+1}=x_{A,n}+v_{cm}\Delta t-\frac{m_B}{M}\Delta x_n,
\qquad
x_{B,n+1}=x_{B,n}+v_{cm}\Delta t+\frac{m_A}{M}\Delta x_n.
\tag{27}
\]
式 (22)–(27) 即 forGPT.md 给出的“只做一次指数映射，其余全是代数更新”的结构。

当存在外力且在每步内近似常值（或你采用分段常值输入），仍可用式 (10)(21) 给出解析推进：  
\[
v_{cm}^{+}=v_{cm}+a_{cm}\tau,\qquad
x_{cm}^{+}=x_{cm}+v_{cm}\tau+\frac12 a_{cm}\tau^2.
\tag{28}
\]
再配合式 (21) 的 \(x,u\) 更新与式 (18)(19) 反解回原坐标即可。

### 矩阵指数与齐次坐标的等价性（对应需求四与七）

**[复现+补充推导]** 大多数分段内动力学可写为 LTI 仿射系统
\[
\dot{\mathbf y}=A\mathbf y+\mathbf b,\qquad \mathbf y(0)=\mathbf y_0.
\tag{29}
\]
其解可用矩阵指数表达：
\[
\mathbf y(t)=e^{At}\mathbf y_0+\int_0^t e^{A(t-\tau)}\mathbf b\,d\tau.
\tag{30}
\]
矩阵指数是求解线性 ODE 的标准工具。citeturn3search48turn2search43

deepseek 文本中的“齐次坐标技巧”本质上是把仿射系统转为线性系统：定义增广状态  
\[
\tilde{\mathbf y}=\begin{bmatrix}\mathbf y\\1\end{bmatrix},
\qquad
\dot{\tilde{\mathbf y}}=
\underbrace{\begin{bmatrix}A&\mathbf b\\\mathbf 0^\mathsf T&0\end{bmatrix}}_{\tilde A}
\tilde{\mathbf y}.
\tag{31}
\]
则
\[
\tilde{\mathbf y}(t)=e^{\tilde A t}\tilde{\mathbf y}(0),
\tag{32}
\]
从而离散一步映射为 \(\tilde{\mathbf y}_{n+1}=e^{\tilde A\Delta t}\tilde{\mathbf y}_n\)。齐次坐标把平移/常输入统一为矩阵乘法，这是计算机图形学与控制中常用的标准做法。citeturn3search49

**符号一致性提醒（对应需求七）**：deepseek 的“带电粒子+旋转矩阵块”段落在 \(J\) 与 \(R(\theta)\) 的约定上存在“符号翻转风险”；本报告建议你在论文中采取规则：**先固定 \(J=\begin{bmatrix}0&-1\\1&0\end{bmatrix}\) 与 \(R(\theta)=\cos\theta I+\sin\theta J\)，再由积分 \(\int_0^{\Delta t}R(\omega\tau)d\tau\) 推出位置块**，以消除歧义。这一点属于“写作规范性修正”，并不影响双杆主体模型。

## 事件化碰撞与有界磁场状态机

本节要点：碰撞与有界磁场边界都视作“事件”；每个事件间隔内系统为常系数线性/仿射 ODE，因此可解析推进；事件发生时施加瞬时映射或模式切换。核心产物是：**四个磁场模式 S0–S3 + 碰撞映射**组成的状态机。

### 碰撞事件的判据、时间定位与瞬时映射（对应需求五）

**碰撞判据（接触）**：  
\[
x(t)=x_B(t)-x_A(t)=0,\quad \text{且发生前 }x>0.
\tag{33}
\]
在无外力、无界磁场（相对模态 \(u(t)=u_0e^{-\alpha t}\)）时，碰撞时间可闭式求解。由式 (16)（取 \(u_\infty=0\)）令 \(x(t_c)=0\)：
\[
0=x_0+\frac{u_0}{\alpha}\big(1-e^{-\alpha t_c}\big)
\ \Rightarrow\
e^{-\alpha t_c}=1+\frac{\alpha x_0}{u_0}.
\tag{34}
\]
存在有限碰撞当且仅当 \(u_0<0\) 且 \(1+\alpha x_0/u_0\in(0,1)\)。此时
\[
t_c=-\frac1\alpha\ln\Big(1+\frac{\alpha x_0}{u_0}\Big).
\tag{35}
\]
这是 forGPT.md 的“无需二分法也能精确处理碰撞”的关键闭式结果。

**碰撞映射（恢复系数）**：碰撞持续时间很短，电磁力冲量可忽略，采用经典冲击模型：总动量守恒 + 恢复系数关系（式 (4)）。于是  
- 质心速度连续：
\[
v_{cm}^{+}=v_{cm}^{-}.
\tag{36}
\]
- 相对速度瞬时更新：
\[
u^{+}=-\rho u^{-},\qquad 0\le \rho\le 1.
\tag{37}
\]
- 位置保持接触：
\[
x^{+}=0.
\tag{38}
\]
并由式 (18) 立刻恢复 \(v_A^+,v_B^+\)。

**关于 \(\rho\)**：\(\rho=1\) 为完全弹性、\(\rho=0\) 为完全非弹性（粘住同速）。恢复系数的标准定义及其范围可参考动力学教材与工程力学资料。citeturn6search2turn6search4

### 有界磁场的统一建模：有效重叠长度 \(\ell\)（对应需求五与七）

**[复现] 有界磁场定义**：磁场仅存在于区间 \([x_L,x_R]\)，区内 \(B\) 匀强、区外 \(B=0\)。定义回路在磁场中的有效重叠长度  
\[
\ell(x_A,x_B)=\max\Big(0,\ \min(x_B,x_R)-\max(x_A,x_L)\Big).
\tag{39}
\]
磁通
\[
\Phi=BL\,\ell.
\tag{40}
\]
则电阻功率（焦耳热功率）统一为
\[
P_R=I^2R = k\,\dot \ell^{\,2},
\tag{41}
\]
其中 \(k=B^2L^2/R\)（式 (2)）。这与“涡流制动/电磁制动的耗散功率与速度相关”的典型结论一致。citeturn4search47turn5search0

**[复现+补充推导] 能量一致性的磁力选取**：在每个模式中 \(\ell\) 是 \((x_A,x_B)\) 的分段线性函数，满足
\[
\dot\ell=\frac{\partial \ell}{\partial x_A}v_A+\frac{\partial \ell}{\partial x_B}v_B,
\quad
\frac{\partial \ell}{\partial x_A}\in\{0,-1\},
\ \frac{\partial \ell}{\partial x_B}\in\{0,1\}.
\tag{42}
\]
为保证“机械功率损失 = 电阻耗散功率”，取
\[
F_{mag,A}=-k\,\dot\ell\,\frac{\partial \ell}{\partial x_A},
\qquad
F_{mag,B}=-k\,\dot\ell\,\frac{\partial \ell}{\partial x_B}.
\tag{43}
\]
则
\[
F_{mag,A}v_A+F_{mag,B}v_B=-k\dot\ell^2=-P_R,
\tag{44}
\]
保证能量账一致（这也是楞次定律“阻止通量变化→产生阻尼”的力学化表达）。citeturn5search1turn4search47

### 四个模式 S0–S3 及其解析推进（对应需求五与七）

这一部分是 forGPT.md 的关键工程化成果：**所有情形都落回三类可解析系统：匀加速、单杆阻尼、双杆耦合**。

- **S0（无重叠或 \(\ell\) 常数）**：\(\dot\ell=0\Rightarrow F_{mag,A}=F_{mag,B}=0\)。两杆各自匀加速推进。  
- **S1（仅 A 在场内）**：\(\dot\ell=-v_A\Rightarrow\) A 受磁阻尼 \( -k v_A\)，B 匀加速。  
- **S2（仅 B 在场内）**：\(\dot\ell=v_B\Rightarrow\) B 受磁阻尼 \( -k v_B\)，A 匀加速。  
- **S3（两杆都在场内且 \(\ell=x_B-x_A\)）**：\(\dot\ell=u\Rightarrow\) 回到无界双杆耦合模型（式 (7)(13)）。

各模式的显式推进公式（本报告后续在 MATLAB 代码中直接实现）与 forGPT.md 一致；对于单杆阻尼模式，典型形式为
\[
v^{+}=v_\infty+(v-v_\infty)e^{-\alpha\tau},\quad
x^{+}=x+v_\infty\tau+\frac{v-v_\infty}{\alpha}\big(1-e^{-\alpha\tau}\big),
\tag{45}
\]
其中 \(v_\infty=F/k\)、\(\alpha=k/m\)。这与线性阻尼系统的解析解结构一致，可用矩阵指数理解。citeturn3search48turn2search43

### 统一状态机算法与伪代码（对应需求五、七、十）

每个定时器步长 \(\Delta t\) 内可能发生多个事件（例如先触边界再碰撞）。因此推荐“剩余时间 \(\tau\)”循环：每次取**最早**事件推进到事件时刻，施加映射/切换，再继续。

**事件集合**  
- 碰撞事件：\(x(t)=0\)（式 (33)）。  
- 边界事件：\(x_A(t)=x_L/x_R\) 或 \(x_B(t)=x_L/x_R\) 导致模式切换。  
- 外力变化：若你设计为“分段常值输入”，则外力变化可视作事件（改变参数，状态连续）。

**伪代码（论文级）**：

```
给定状态 S(t_n)，步长 Δt，令 τ ← Δt
while τ > 0:
    mode ← DetermineMode(xA, xB, xL, xR)
    计算在该 mode 下、时间 τ 的解析预测末态 S_pred = Flow(mode, S, τ)
    枚举事件集合 E：
        计算每类事件在 (0, τ] 内的最早发生时刻 t_e（若不存在则为 +∞）
    若 min_e t_e = +∞:
        S ← S_pred; τ ← 0
    else:
        t* ← min_e t_e
        S ← Flow(mode, S, t*)
        S ← ApplyEvent(S, event_type_at_t*)
        τ ← τ - t*
end
输出 S(t_{n+1})
```

事件时刻求解：在无外力无界 S3 碰撞可用闭式式 (35)；其余一般用根求解（牛顿/二分或 MATLAB 的 `fzero`），并保证 bracket 内存在符号变化。`fzero` 的算法与输入要求见 entity["company","MathWorks","matlab developer"] 官方文档。citeturn1search0

## 能量与热量递推及二次项扩维

本节要点：给出系统能量分解与热量递推；证明 forGPT.md 中“相对动能→焦耳热”的结论；解释热量递推的非线性来源；给出两类扩维线性化策略（最小扩维与 Kronecker 提升）并比较。

### 动能分解与无外力下的热量闭式（对应需求六）

在无外力、无摩擦、无界匀强磁场（S3）且不考虑碰撞瞬时内耗时，系统总动能可分解为
\[
K=\frac12 M v_{cm}^2+\frac12 \mu u^2.
\tag{46}
\]
由于 \(v_{cm}\) 常量（式 (10)），只有相对动能 \(\frac12\mu u^2\) 衰减。

电阻耗散功率
\[
P_R=I^2R = k u^2
\tag{47}
\]
（这是由式 (6) 直接得到的“功率与 \(u^2\) 成正比”）。该结构与“涡流制动耗散与速度相关”的经典判断一致。citeturn4search47

由 \(u(t)=u_0e^{-\alpha t}\)（式 (15)）得
\[
P_R(t)=k u_0^2 e^{-2\alpha t},
\qquad
Q(t)=\int_0^t P_R(s)\,ds=\frac{k u_0^2}{2\alpha}\big(1-e^{-2\alpha t}\big).
\tag{48}
\]
取 \(t\to\infty\)，并用 \(\alpha=k/\mu\)（式 (12)）得
\[
Q(\infty)=\frac12 \mu u_0^2,
\tag{49}
\]
即 **最终发热 = 初始相对动能**（forGPT.md 的“神来之笔”）。

### 热量的统一递推：功-能公式（对应需求六）

当存在外力与有界磁场模式切换时，直接用 \(P_R=k\dot\ell^2\) 做积分虽可行，但工程上更稳的做法是用统一能量账：

由式 (44) 得电磁力对机械系统做功率为 \(-P_R\)。因此总动能满足
\[
\frac{dK}{dt}=F_A v_A+F_B v_B - P_R.
\tag{50}
\]
移项并积分（在任意解析推进段 \([t,t+\tau]\) 内）：
\[
\Delta Q = \int_t^{t+\tau} P_R\,ds 
= \underbrace{\int_t^{t+\tau}(F_Av_A+F_Bv_B)\,ds}_{W_{ext}}
-\Delta K.
\tag{51}
\]
离散实现中，若外力在该段内常值，则
\[
W_{ext}=F_A\Delta x_A+F_B\Delta x_B,
\tag{52}
\]
从而可以用“端点状态”计算段增量
\[
Q^{+}=Q+\big(F_A(x_A^{+}-x_A)+F_B(x_B^{+}-x_B)\big)
-\Big[\tfrac12 m_A\big((v_A^{+})^2-v_A^2\big)+\tfrac12 m_B\big((v_B^{+})^2-v_B^2\big)\Big].
\tag{53}
\]
这正是 forGPT.md 给出的“所有模式通用的热量递推”。

**碰撞热（非电阻热）**：若 \(\rho<1\)，碰撞瞬时会损失相对动能
\[
Q_{coll}
=\frac12\mu\big((u^{-})^2-(u^{+})^2\big)
=\frac12\mu(1-\rho^2)(u^{-})^2.
\tag{54}
\]
该能量应单独记账（形变热/声等），不计入电阻焦耳热 \(Q\)。

### 二次项导致的非线性与两种扩维策略（对应需求六）

**问题本质**：无论你用 \(P_R=k\dot\ell^2\) 还是用式 (53)，热量递推都涉及 \(v^2\) 或 \(u^2\)，因此若原系统状态满足线性/仿射递推
\[
s_{n+1}=A s_n + c,
\tag{55}
\]
则 \(Q\) 的递推一般不是线性闭合的：出现 \(s_n^\mathsf T H s_n\) 之类二次型项（deepseek 文本也指出了这一点）。

#### 策略一：最小扩维（单模态/少量二次项）

核心想法：只引入“你确实需要的二次单项式”，而不是把所有二次单项式都引入。

- **示例（最简单、最常用）**：相对模态在分段内常为仿射标量递推  
\[
u_{n+1}=a u_n+b.
\tag{56}
\]
则
\[
u_{n+1}^2=(a u_n+b)^2=a^2 u_n^2+2ab\,u_n+b^2.
\tag{57}
\]
因此只要把状态从 \([u]\) 扩为 \([u^2,u,1]\)，就能写成线性递推
\[
\begin{bmatrix}u_{n+1}^2\\u_{n+1}\\1\end{bmatrix}
=
\begin{bmatrix}
a^2 & 2ab & b^2\\
0 & a & b\\
0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}u_n^2\\u_n\\1\end{bmatrix}.
\tag{58}
\]
再将 \(Q\) 的段增量写成 \(u_n^2,u_n,1\) 的线性组合即可闭合。

- **对双杆全状态的最小扩维**：若你用式 (53) 直接更新 \(Q\)，只涉及 \(v_A^2,v_B^2\)。因此可选扩维集  
\[
\{v_A^2,\ v_B^2,\ v_Av_B\}
\tag{59}
\]
（若需要交叉项），并在每个模式内用显式代数更新得到其线性递推闭合。

优点：维度小、可解释性强、实现简单。缺点：对多模式/复杂输入需手工推导每个模式的二次项更新。

#### 策略二：Kronecker 积/二次型提升（系统化、可自动化）

对增广线性映射（齐次坐标）
\[
\tilde s_{n+1}=\tilde A \tilde s_n,
\tag{60}
\]
考虑二次提升变量 \(W_n=\tilde s_n\tilde s_n^\mathsf T\)。则
\[
W_{n+1}=\tilde A W_n \tilde A^\mathsf T.
\tag{61}
\]
若以向量化算子 \(\mathrm{vec}(\cdot)\) 堆叠矩阵列，则有著名恒等式
\[
\mathrm{vec}( \tilde A W_n \tilde A^\mathsf T)
=(\tilde A\otimes \tilde A)\,\mathrm{vec}(W_n).
\tag{62}
\]
这就是 Kronecker 积“把二次项空间变成线性空间”的标准工具。citeturn2search42

优点：通用、可自动生成（对每个模式给 \(\tilde A\)，即可生成二次提升矩阵）。缺点：维度膨胀显著：若 \(\tilde s\in\mathbb R^{n}\)，则 \(W\) 维度为 \(n^2\)。

#### 两策略对比（对应需求六）

| 维度 | 最小扩维 | Kronecker 提升 |
|---|---|---|
| 维度规模 | 取决于你选的二次项数量（常很小） | \(n^2\)（显著增大） |
| 推导成本 | 每个模式需手工列二次项更新 | 统一公式自动生成（式 (61)(62)） |
| 计算复杂度 | 低（常 \(O(n)\) 或 \(O(n^2)\)） | 若直接乘 \(n^2\times n^2\) 矩阵代价高；但可用 \(W_{n+1}=\tilde A W_n\tilde A^\mathsf T\) 形式降为 \(O(n^3)\) |
| 可解释性 | 强（每个二次项有物理意义） | 中等（高维提升空间较抽象） |
| 适用场景建议 | 教学/工程实时仿真首选 | 需要自动化生成、做理论分析或高阶矩估计时使用；与 **Carleman 线性化**思想相近 citeturn3search47turn3search0 |

## MATLAB timer 事件驱动仿真与验证

本节要点：给出 timer 框架选择理由、可运行的代码组织与关键回调；展示事件时刻高精度定位方案（闭式/`fzero`）；设计 ≥4 个测试用例并给出预期结果与验证方法；最后分析复杂度与数值稳定性。

### 为什么用 timer（对应需求八）

**优势**：  
- 支持固定节拍回调，适于**实时可视化**、交互式调参、与外设/GUI 联动。  
- 可显式实现“每 tick 推进一步”的教学式呈现。

**局限**：  
- timer 的触发受 MATLAB 执行队列与系统调度影响，真实时间间隔并不严格等于仿真步长；因此应区分：  
  - **仿真步长** \(\Delta t\)（状态推进用）  
  - **墙钟周期** `t.Period`（回调调度用）  
- 性能瓶颈通常来自图形刷新与事件根求解，不来自解析推进本身。

`timer` 的关键属性與回调（`TimerFcn`, `ExecutionMode`, `Period`, `TasksToExecute` 等）请以 entity["company","MathWorks","matlab developer"] 官方文档为准。citeturn0search0

### 仿真框架：文件结构建议（对应需求十三）

建议你把工程实现拆成以下文件（便于复用与论文附录展示）：

- `simulate_two_rod_timer.m`：主入口（创建参数、图窗与 timer）。  
- `propagate_mode.m`：给定模式 S0/S1/S2/S3 与时长 \(\tau\)，用解析公式推进状态。  
- `find_next_event.m`：在当前模式下计算最早事件时间与类型（碰撞/边界）。  
- `apply_event.m`：执行碰撞映射或模式切换（含 \(Q_{coll}\) 记账）。  
- `plot_results.m`：离线绘图（位置/速度/能量/事件标注等）。  

### 可直接运行的示例代码（主框架，含详注释）

> 说明：以下代码为“教学友好版”：  
> 1) 外力设为分段常值；  
> 2) 事件时刻定位优先用闭式（无外力无界碰撞），其余用 `fzero`；  
> 3) 只展示 S0/S1/S2/S3 与碰撞三类事件，并用能量法更新 \(Q\)。  
> 你可在此基础上扩展（例如加入 LambertW 闭式、或更鲁棒的 bracket 搜索）。

```matlab
function simulate_two_rod_timer()
% 双杆 + 外力 + 碰撞 + 有界磁场：timer 事件驱动仿真（解析推进，无截断误差）
% 2026-02-10
%
% 运行：在 MATLAB 命令行输入 simulate_two_rod_timer

%------------------------%
% 1) 参数（可自行改）     %
%------------------------%
P.mA = 1.0;          % kg (建议 SI；原文未指定)
P.mB = 2.0;          % kg
P.B  = 1.0;          % T
P.L  = 1.0;          % m
P.R  = 1.0;          % Ohm
P.k  = (P.B^2)*(P.L^2)/P.R;

P.xL = 0.0;          % 有界磁场左边界
P.xR = 1.0;          % 有界磁场右边界

P.rho = 0.5;         % 恢复系数 ρ in [0,1]
P.dt  = 0.01;        % 仿真步长 Δt（仿真时间）
P.tEnd = 8.0;        % 总仿真时长

% 外力（可扩展为随时间变化；这里示例取常量）
P.FA = 0.0;          % N
P.FB = 0.0;          % N

% timer 真实调度周期（墙钟时间）；建议 >= P.dt 且 >= 0.001
wallPeriod = 0.02;

%------------------------%
% 2) 初值                %
%------------------------%
S.t  = 0.0;
S.xA = -0.2;
S.vA =  0.3;
S.xB =  0.6;
S.vB =  0.0;
S.Q  = 0.0;     % 电阻焦耳热
S.Qcoll = 0.0;  % 碰撞内耗热
S.events = [];  % [t, code] 记录事件：1=collision, 2=boundary

%------------------------%
% 3) 图窗与数据缓存      %
%------------------------%
fig = figure('Name','Two-rod event-driven simulation (timer)','NumberTitle','off');
ax1 = subplot(3,1,1); hold(ax1,'on'); grid(ax1,'on'); ylabel(ax1,'x');
ax2 = subplot(3,1,2); hold(ax2,'on'); grid(ax2,'on'); ylabel(ax2,'v');
ax3 = subplot(3,1,3); hold(ax3,'on'); grid(ax3,'on'); ylabel(ax3,'Q'); xlabel(ax3,'t');

buf.cap = ceil(P.tEnd/P.dt)+5;
buf.t  = nan(buf.cap,1);
buf.xA = nan(buf.cap,1); buf.xB=nan(buf.cap,1);
buf.vA = nan(buf.cap,1); buf.vB=nan(buf.cap,1);
buf.Q  = nan(buf.cap,1); buf.Qcoll=nan(buf.cap,1);
buf.i  = 1;

h1 = plot(ax1, nan, nan); % xA
h2 = plot(ax1, nan, nan); % xB
h3 = plot(ax2, nan, nan); % vA
h4 = plot(ax2, nan, nan); % vB
h5 = plot(ax3, nan, nan); % Q
h6 = plot(ax3, nan, nan); % Qcoll

%------------------------%
% 4) 定义 timer 回调      %
%------------------------%
tObj = timer( ...
    'ExecutionMode','fixedSpacing', ...
    'Period', wallPeriod, ...
    'TimerFcn', @onTick, ...
    'StopFcn',  @onStop);

start(tObj);

    function onTick(~,~)
        if ~isvalid(fig)
            stop(tObj); delete(tObj); return;
        end
        if S.t >= P.tEnd
            stop(tObj); delete(tObj); return;
        end

        % 一个 tick：把仿真推进 Δt（内部可能细分多个事件）
        S = advance_one_step(S, P);

        % 记录数据
        if buf.i <= buf.cap
            buf.t(buf.i)  = S.t;
            buf.xA(buf.i) = S.xA; buf.xB(buf.i)=S.xB;
            buf.vA(buf.i) = S.vA; buf.vB(buf.i)=S.vB;
            buf.Q(buf.i)  = S.Q;  buf.Qcoll(buf.i)=S.Qcoll;
            buf.i = buf.i + 1;
        end

        % 刷新绘图（简化：每步刷新；若卡顿可降低刷新频率）
        idx = 1:(buf.i-1);
        set(h1,'XData',buf.t(idx),'YData',buf.xA(idx));
        set(h2,'XData',buf.t(idx),'YData',buf.xB(idx));
        set(h3,'XData',buf.t(idx),'YData',buf.vA(idx));
        set(h4,'XData',buf.t(idx),'YData',buf.vB(idx));
        set(h5,'XData',buf.t(idx),'YData',buf.Q(idx));
        set(h6,'XData',buf.t(idx),'YData',buf.Qcoll(idx));
        drawnow limitrate;
    end

    function onStop(~,~)
        if isvalid(fig)
            disp('Simulation finished.');
        end
    end
end

%========================%
% 解析推进 + 事件处理核心 %
%========================%
function S = advance_one_step(S, P)
tau = P.dt;
while tau > 0
    mode = determine_mode(S, P);  % 'S0','S1','S2','S3'

    % 找到最早事件（若无事件，返回 empty）
    [tEvent, eType] = find_next_event(S, P, mode, tau);

    if isempty(eType)
        S = propagate_mode(S, P, mode, tau);  % 解析推进满 τ
        tau = 0;
    else
        % 先推进到事件时刻
        S = propagate_mode(S, P, mode, tEvent);

        % 应用事件（碰撞或边界切换）
        S = apply_event(S, P, eType);

        tau = tau - tEvent;
    end
end
end

function mode = determine_mode(S, P)
% 根据 (xA,xB) 与 [xL,xR] 判断磁场模式
xA = S.xA; xB = S.xB; xL = P.xL; xR = P.xR;

% 有效重叠长度
ell = max(0, min(xB,xR) - max(xA,xL));

if ell <= 0
    mode = 'S0';
    return;
end

A_in = (xA >= xL) && (xA <= xR);
B_in = (xB >= xL) && (xB <= xR);

if A_in && B_in
    mode = 'S3';
elseif A_in && ~B_in
    mode = 'S1';
elseif ~A_in && B_in
    mode = 'S2';
else
    % 例如 xA < xL 且 xB > xR：ell = xR-xL 常数 => dot ell = 0
    mode = 'S0';
end
end

function S2 = propagate_mode(S, P, mode, tau)
% 用解析公式推进 tau，并用能量账更新 Q
S0 = S;  % 保存段首
mA=P.mA; mB=P.mB; k=P.k; FA=P.FA; FB=P.FB;

switch mode
    case 'S0'
        aA = FA/mA; aB = FB/mB;
        S.vA = S.vA + aA*tau;
        S.xA = S.xA + S0.vA*tau + 0.5*aA*tau^2;
        S.vB = S.vB + aB*tau;
        S.xB = S.xB + S0.vB*tau + 0.5*aB*tau^2;

    case 'S1' % only A damped
        alphaA = k/mA;
        vAinf = (k>0) * (FA/k);
        S.vA = vAinf + (S.vA - vAinf)*exp(-alphaA*tau);
        S.xA = S.xA + vAinf*tau + (S0.vA - vAinf)/alphaA*(1-exp(-alphaA*tau));

        aB = FB/mB;
        S.vB = S.vB + aB*tau;
        S.xB = S.xB + S0.vB*tau + 0.5*aB*tau^2;

    case 'S2' % only B damped
        alphaB = k/mB;
        vBinf = (k>0) * (FB/k);
        S.vB = vBinf + (S.vB - vBinf)*exp(-alphaB*tau);
        S.xB = S.xB + vBinf*tau + (S0.vB - vBinf)/alphaB*(1-exp(-alphaB*tau));

        aA = FA/mA;
        S.vA = S.vA + aA*tau;
        S.xA = S.xA + S0.vA*tau + 0.5*aA*tau^2;

    case 'S3' % coupled (use cm + relative)
        M = mA+mB; mu = mA*mB/M;
        alpha = k*(1/mA+1/mB);
        aCM = (FA+FB)/M;
        b    = FB/mB - FA/mA;
        uInf = b/alpha;

        xCM = (mA*S.xA + mB*S.xB)/M;
        vCM = (mA*S.vA + mB*S.vB)/M;
        x   = S.xB - S.xA;
        u   = S.vB - S.vA;

        lam = exp(-alpha*tau);
        vCM2 = vCM + aCM*tau;
        xCM2 = xCM + vCM*tau + 0.5*aCM*tau^2;

        u2 = uInf + (u - uInf)*lam;
        x2 = x   + uInf*tau + (u - uInf)/alpha*(1-lam);

        % map back
        vA2 = vCM2 - (mB/M)*u2;  vB2 = vCM2 + (mA/M)*u2;
        xA2 = xCM2 - (mB/M)*x2;  xB2 = xCM2 + (mA/M)*x2;

        S.xA=xA2; S.vA=vA2; S.xB=xB2; S.vB=vB2;

    otherwise
        error('Unknown mode.');
end

% 更新时间
S.t = S.t + tau;

% 用功-能账更新焦耳热 Q（适用于所有模式的连续推进段）
Wext = FA*(S.xA - S0.xA) + FB*(S.xB - S0.xB);
dK   = 0.5*mA*(S.vA^2 - S0.vA^2) + 0.5*mB*(S.vB^2 - S0.vB^2);
S.Q  = S.Q + (Wext - dK);

S2 = S;
end

function [tEvent, eType] = find_next_event(S, P, mode, tauMax)
% 返回最早事件 (tEvent, eType)；若无事件则 eType=[]
% 事件：碰撞（x=0）或边界（模式切换）
tCandidates = [];
eCandidates = {};

% 1) 碰撞候选：只要预测会穿透，就在 [0,tauMax] 内找 x(t)=0
x0 = S.xB - S.xA;
if x0 > 0
    Sp = propagate_mode(S, P, mode, tauMax);
    xp = Sp.xB - Sp.xA;
    if xp < 0
        % bracket root on g(t)=x(t) in [0,tauMax]
        g = @(tt) (relative_gap_at(S,P,mode,tt));
        tCol = fzero(g, [0, tauMax]);  % 需保证符号变化
        if tCol > 0 && tCol <= tauMax
            tCandidates(end+1) = tCol; %#ok<AGROW>
            eCandidates{end+1} = 'collision'; %#ok<AGROW>
        end
    end
end

% 2) 边界候选：检查 xA 或 xB 是否穿越 xL/xR
% 使用符号变化 + fzero；对 S0 的二次式可用显式解，但这里统一用 fzero
for which = ["A","B"]
    for xb = [P.xL, P.xR]
        h = @(tt) boundary_func(S, P, mode, tt, which, xb);
        h0 = h(0); h1 = h(tauMax);
        if h0==0
            % 已在边界上：不作为事件（避免死循环）
            continue;
        end
        if sign(h0) ~= sign(h1)
            tB = fzero(h, [0, tauMax]);
            if tB > 0 && tB <= tauMax
                tCandidates(end+1) = tB; %#ok<AGROW>
                eCandidates{end+1} = 'boundary'; %#ok<AGROW>
            end
        end
    end
end

if isempty(tCandidates)
    tEvent = []; eType = [];
else
    [tEvent, idx] = min(tCandidates);
    eType = eCandidates{idx};
end
end

function xgap = relative_gap_at(S,P,mode,tt)
St = propagate_mode(S,P,mode,tt);
xgap = St.xB - St.xA;
end

function val = boundary_func(S,P,mode,tt,which,xb)
St = propagate_mode(S,P,mode,tt);
switch which
    case "A"
        val = St.xA - xb;
    case "B"
        val = St.xB - xb;
    otherwise
        error('which must be A or B');
end
end

function S = apply_event(S, P, eType)
switch eType
    case 'collision'
        % 碰撞：用 v_cm 不变 + u^+ = -rho u^- 更新
        mA=P.mA; mB=P.mB; M=mA+mB; mu=mA*mB/M;
        vCM = (mA*S.vA + mB*S.vB)/M;
        uMinus = S.vB - S.vA;

        uPlus = -P.rho*uMinus;

        % 记录碰撞热（不计入电阻热）
        S.Qcoll = S.Qcoll + 0.5*mu*(uMinus^2 - uPlus^2);

        % 更新速度
        S.vA = vCM - (mB/M)*uPlus;
        S.vB = vCM + (mA/M)*uPlus;

        % 位置纠正为接触（数值容差处理）
        xMid = 0.5*(S.xA + S.xB);
        S.xA = xMid; S.xB = xMid;

        S.events(end+1,:) = [S.t, 1]; %#ok<AGROW>

    case 'boundary'
        % 边界事件：状态连续；下一次 determine_mode 会自动更新模式
        S.events(end+1,:) = [S.t, 2]; %#ok<AGROW>

    otherwise
        error('Unknown event type.');
end
end
```

**事件根求解说明**：上述 `fzero` 使用 bracket `[0,tau]`，它要求端点函数值异号（或包含根），并采用二分/割线/反二次插值的组合算法，是工程上常用的一维求根器。citeturn1search0  
**重要提醒**：如果 \(x(t)\) 在区间内不单调，你可能出现“端点同号但中间穿越”的漏检；建议在高风险场景加入“区间采样找变号段”的补丁（见稳定性讨论）。

### 可视化建议与绘图片段（对应需求八）

建议至少给出四类图，并用事件时间标注（碰撞、入场/出场）：

1) 位置 \(x_A(t),x_B(t)\) 与边界 \(x_L,x_R\)；  
2) 速度 \(v_A(t),v_B(t)\) 与相对速度 \(u(t)\)；  
3) 相图：\((x,u)\) 或 \((x_A,v_A)\)；  
4) 能量/热量：\(Q(t)\)、\(Q_{coll}(t)\)、总动能 \(K(t)\) 与外力功累计。

事件标注示例（离线绘图）：
```matlab
% 假设 events 是 [t, code]
for i = 1:size(events,1)
    if events(i,2)==1
        xline(events(i,1),'--'); % collision
    else
        xline(events(i,1),':');  % boundary
    end
end
```

### 数值验证与测试用例设计（对应需求九）

下表给出 4 个最小覆盖用例（参数可直接代入上面代码）。若你采用 SI，只需保证量纲一致即可。

| 用例 | 目的 | 关键参数（示例） | 预期结果与验证 |
|---|---|---|---|
| 无碰撞纯阻尼衰减 | 验证 \(u(t)=u_0e^{-\alpha t}\) 与 \(Q(\infty)=\frac12\mu u_0^2\) | 无界 S3：\(F_A=F_B=0\)，选 \(m_A=1,m_B=2,B=L=R=1\)，初值 \(x_0>0,u_0>0\) | 拟合 \(\ln u\) 与 \(t\) 得斜率 \(-\alpha\)；验证 \(Q(t)\) 逼近 (49)；误差用相对误差 \(|Q-\frac12\mu u_0^2|/(\frac12\mu u_0^2)\) |
| 单次碰撞 | 验证闭式碰撞时刻 (35) 与映射 (37) 与 \(Q_{coll}\) | 无外力无界 S3：选 \(u_0<0\) 且 \(x_0+\frac{u_0}{\alpha}<0\)，比如 \(x_0=0.1,u_0=-0.5\)；\(\rho=0.5\) | 事件时间与 (35) 对比；碰后 \(u^+\approx-\rho u^-\)；验证碰撞热 (54) |
| 多次快速碰撞序列 | 验证事件循环鲁棒性（同一 Δt 内多事件） | 让相对稳态速度为负：设 \(F_A=-F_B\) 且 \(b<0\)（如 \(m_A=m_B=1,F_A=+1,F_B=-1\)）并取 \(\rho>0\) | 观察 \(x(t)\) 多次回到 0；检查无穿透 \(x\ge 0\)；检查事件时间序列单调递增 |
| 扩维热量线性化对比 | 比较“直接二次计算”与“扩维线性递推”误差与成本 | 选择单杆阻尼模式 S1 或相对模态递推 (56)，并用 (58) 扩维 | 比较 \(u^2\) 直接平方与线性递推结果；给出 RMSE 与每步耗时对比（`timeit`） |

**容差建议**：  
- 事件根求解 `fzero`：`TolX` 可取 \(10^{-10}\sim10^{-12}\)（视尺度）；  
- 无穿透约束可取 `epsX = 1e-12`，碰撞后强制 \(x=0\)；  
- 能量账一致性检查：每步计算
\[
\varepsilon_n \equiv \big(W_{ext,n}-\Delta K_n\big)-\Delta Q_n,
\]
理想应接近 0（浮点误差量级）。

### 算法复杂度与数值稳定性（对应需求十）

**复杂度**：  
- 解析推进（S0/S1/S2/S3）为常数时间 \(O(1)\)。  
- 每步事件检测需要若干次 `propagate_mode` 评估与 `fzero` 函数评估：若 `fzero` 迭代次数约为 \(N_f\)，则每步约 \(O(N_f)\)。  
- 若同一 \(\Delta t\) 内发生 \(E\) 个事件，则该步复杂度乘以 \(E\)，即 \(O(E N_f)\)。在多次碰撞用例中应重点关注此项。

**稳定性与漏检风险**：  
1) **指数衰减数值问题**：当 \(\alpha\Delta t\) 很大时 \(\exp(-\alpha\Delta t)\) 可能下溢到 0；建议在需要高精度差分时用 `expm1` 形式改写 \(1-e^{-\alpha\tau}\)。  
2) **事件漏检**：固定步长下若只看端点可能漏掉“中间触边界再返回”的情况。缓解方法：  
   - 对关键事件函数 \(g(t)\) 在区间内采样（例如 3～5 点）寻找变号子区间；  
   - 或者使用保守上界（例如对二次函数用判别式）；  
   - 或缩小 \(\Delta t\)。  
3) **碰撞不连续**：速度瞬时跳变是物理模型决定的；数值上需避免“二次触发”：碰撞后可以设置一个极小的“事件死区”（例如若 \(|x|<\epsilon\) 则不再立刻判碰撞）。

## 扩展、未指定项与参考文献及快速开始

本节要点：给出推广到多杆链、控制输入与扰动的结构化建议；集中列出未指定项的可选范围；提供优先来源参考文献；最后给出≤100 行的“快速开始”最小示例（无界磁场+碰撞）。

### 扩展与应用建议（对应需求十一）

1) **多质点/多杆链式系统**：把 \((x_i,v_i)\) 堆叠成 \(2N\) 维状态；无界匀强磁场下相对模态会变成一个带耦合的线性系统 \(\dot s = A s\)，仍可用矩阵指数或结构化分解（如模态分析）处理。矩阵指数是线性系统通用解法。citeturn3search48  
2) **加入控制输入**：把 \(F_A,F_B\) 视作输入 \(u(t)\)，系统成为仿射控制系统；若保持“分段常值”输入，则每段仍可解析推进（本报告代码已按此组织）。  
3) **随机扰动/噪声**：可在每 tick 后叠加扰动（如 \(v\leftarrow v+\sigma\sqrt{\Delta t}\xi\)），但会破坏纯解析无截断性质；适用场景为鲁棒性/蒙特卡洛。  
4) **应用场景**：  
   - 电磁制动/涡流阻尼的等效建模（速度相关耗散）；citeturn4search47  
   - 机器人接触/碰撞过程（恢复系数+事件驱动）；citeturn6search2  
   - 分段线性系统与混杂系统（hybrid systems）教学演示：连续流+离散跳变（本模型是非常干净的教学例子）。

### 参考文献与优先来源（对应需求十二）

**优先来源：你的 forGPT.md**  
```text
sandbox:/mnt/data/forGPT.md
```

**电磁学基本定律与力**  
- entity["organization","Encyclopaedia Britannica","encyclopedia publisher"]：法拉第电磁感应定律（emf = −dΦ/dt）。citeturn5search0  
- entity["organization","OpenStax","open textbooks"]：楞次定律（感应效应反对磁通变化）。citeturn5search1  
- entity["people","Hendrik Lorentz","physicist"] 的洛伦兹力与载流导体受力形式（百科概述）。citeturn4search1  

**碰撞与恢复系数**  
- 工程力学教材型资料：恢复系数 \(0\le e\le 1\)、能量损失与 \(e^2\) 关系。citeturn6search2turn6search4  

**矩阵化与二次项提升**  
- 矩阵指数与线性 ODE：矩阵指数用于线性系统求解。citeturn3search48turn3search5  
- Kronecker 积与 vec 技巧：\(\mathrm{vec}(AXB)=(B^\mathsf T\otimes A)\mathrm{vec}(X)\)。citeturn2search42  
- entity["people","Leopold Kronecker","mathematician"] 命名的 Kronecker 积背景（术语来源）。citeturn2search42  
- entity["people","Torsten Carleman","swedish mathematician"]：Carleman 线性化（把多项式非线性提升到高维线性系统的思想）。citeturn3search47turn3search0  

**MATLAB 官方文档（timer/求根）**  
- `timer` 对象：属性、回调与执行模式。citeturn0search0  
- `fzero`：输入、算法（Dekker/Brent 类方法组合）。citeturn1search0  

### 快速开始（≤100 行最小可运行示例）（对应需求十三）

> 目标：无界匀强磁场（相对模态指数衰减）+ 单次碰撞闭式定位（式 (35)）+ 固定步长推进。  
> 运行：复制到 `quickstart_two_rod.m`，在命令行运行 `quickstart_two_rod`。

```matlab
function quickstart_two_rod()
% 最小示例：无界磁场 + 无外力 + 碰撞（闭式定位）+ 解析递推
mA=1; mB=2; M=mA+mB; mu=mA*mB/M;
B=1; L=1; R=1; k=B^2*L^2/R; alpha=k*(1/mA+1/mB);
rho=0.5; dt=0.01; tEnd=3;

% 初值：确保会碰撞（x0 + u0/alpha < 0）
xA=0.0; vA=0.0;
xB=0.1; vB=-0.8;
Q=0; Qcoll=0;

t=0; T=[]; XA=[]; XB=[]; VA=[]; VB=[]; QQ=[]; QC=[];
while t < tEnd
    x = xB-xA; u = vB-vA;
    tau = dt;

    % 检测本步是否会碰撞：预测 x(tau)
    u1 = u*exp(-alpha*tau);
    x1 = x + (u-u1)/alpha;
    if x1 < 0
        % 闭式碰撞时刻（仅适用于 b=0）
        thit = -(1/alpha)*log(1 + alpha*x/u); % u<0
        % 推进到碰撞
        um = u*exp(-alpha*thit);
        xA = xA + (mB/M)*(x - 0); %#ok<NASGU> % 可忽略：这里直接把位置合并更简单
        xB = xA; % 接触
        % 碰撞映射
        up = -rho*um;
        Qcoll = Qcoll + 0.5*mu*(um^2-up^2);
        vcm = (mA*vA+mB*vB)/M;
        vA = vcm - (mB/M)*up; vB = vcm + (mA/M)*up;
        % 剩余时间再推进
        tau2 = tau - thit;
        u = vB-vA;
        u2 = u*exp(-alpha*tau2);
        dx = (u-u2)/alpha;
        xA = xA - (mB/M)*dx; xB = xB + (mA/M)*dx;
        vA = vcm - (mB/M)*u2; vB = vcm + (mA/M)*u2;
        % 电阻热 = 相对动能损失（无外力）
        Q = Q + 0.5*mu*(u^2 - u2^2);
    else
        % 无碰撞：整步推进
        dx = (u-u1)/alpha;
        vcm=(mA*vA+mB*vB)/M;
        xA = xA - (mB/M)*dx; xB = xB + (mA/M)*dx;
        vA = vcm - (mB/M)*u1; vB = vcm + (mA/M)*u1;
        Q = Q + 0.5*mu*(u^2-u1^2);
    end

    t = t + dt;
    T(end+1)=t; XA(end+1)=xA; XB(end+1)=xB; VA(end+1)=vA; VB(end+1)=vB; %#ok<AGROW>
    QQ(end+1)=Q; QC(end+1)=Qcoll;
end

figure; subplot(2,1,1); plot(T,XA,T,XB); grid on; ylabel('x');
subplot(2,1,2); plot(T,VA,T,VB,T,QQ,T,QC); grid on; ylabel('v / Q'); xlabel('t');
legend('vA','vB','Q','Qcoll');
end
```

> 若你要把快速开始升级到“有界磁场 + 多事件 + 外力”，直接迁移到上一节的大框架即可：那份框架将闭式碰撞定位与 `fzero` 根求解统一在同一接口中。